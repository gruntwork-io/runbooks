package api

import (
	"crypto/sha256"
	"encoding/hex"
	"fmt"
	"log/slog"
	"os"
	"path/filepath"
	"sync"
)

// FileManifest tracks files generated by template blocks to enable smart cleanup.
// When a template re-renders with different variables, it can detect which files
// are orphaned and delete them automatically.
//
// This implements "block-scoped file manifests" where each Template component (identified by its ID)
// owns a specific set of generated files. On re-render, only files that are no longer produced
// are deleted, and only files that have changed are rewritten.

// ManifestEntry represents a single file in the manifest with its content hash
type ManifestEntry struct {
	Path        string // Relative path within the output directory
	ContentHash string // SHA256 hash of file content
}

// TemplateManifest stores the files generated by a specific template
type TemplateManifest struct {
	TemplateID string          // The unique ID of the Template component
	OutputDir  string          // The output directory for this template
	Files      []ManifestEntry // Files generated by this template
}

// FileManifestStore is an in-memory store for tracking generated files per template
type FileManifestStore struct {
	mu        sync.RWMutex
	manifests map[string]*TemplateManifest // templateID -> manifest
}

// Global manifest store instance
var globalManifestStore = NewFileManifestStore()

// NewFileManifestStore creates a new manifest store
func NewFileManifestStore() *FileManifestStore {
	return &FileManifestStore{
		manifests: make(map[string]*TemplateManifest),
	}
}

// GetManifestStore returns the global manifest store
func GetManifestStore() *FileManifestStore {
	return globalManifestStore
}

// Get retrieves the manifest for a template ID
func (s *FileManifestStore) Get(templateID string) *TemplateManifest {
	s.mu.RLock()
	defer s.mu.RUnlock()
	return s.manifests[templateID]
}

// Set stores a manifest for a template ID
func (s *FileManifestStore) Set(templateID string, manifest *TemplateManifest) {
	s.mu.Lock()
	defer s.mu.Unlock()
	s.manifests[templateID] = manifest
}

// Delete removes a manifest for a template ID
func (s *FileManifestStore) Delete(templateID string) {
	s.mu.Lock()
	defer s.mu.Unlock()
	delete(s.manifests, templateID)
}

// Clear removes all manifests (useful for testing)
func (s *FileManifestStore) Clear() {
	s.mu.Lock()
	defer s.mu.Unlock()
	s.manifests = make(map[string]*TemplateManifest)
}

// HashFileContent computes the SHA256 hash of file content
func HashFileContent(content []byte) string {
	hash := sha256.Sum256(content)
	return hex.EncodeToString(hash[:])
}

// BuildManifestFromDirectory scans a directory and builds a manifest of all files with their hashes
func BuildManifestFromDirectory(rootDir string) ([]ManifestEntry, error) {
	var entries []ManifestEntry

	err := filepath.Walk(rootDir, func(path string, info os.FileInfo, err error) error {
		if err != nil {
			return err
		}

		// Skip directories
		if info.IsDir() {
			return nil
		}

		// Read file content
		content, err := os.ReadFile(path)
		if err != nil {
			return fmt.Errorf("failed to read file %s: %w", path, err)
		}

		// Get relative path
		relPath, err := filepath.Rel(rootDir, path)
		if err != nil {
			return fmt.Errorf("failed to get relative path for %s: %w", path, err)
		}

		entries = append(entries, ManifestEntry{
			Path:        relPath,
			ContentHash: HashFileContent(content),
		})

		return nil
	})

	if err != nil {
		return nil, err
	}

	return entries, nil
}

// DiffResult contains the result of comparing two manifests
type DiffResult struct {
	// Files that exist in the old manifest but not in the new one (should be deleted)
	Orphaned []string
	// Files that exist in the new manifest but not in the old one (should be created)
	Created []string
	// Files that exist in both but have different content hashes (should be updated)
	Modified []string
	// Files that exist in both with the same content hash (no action needed)
	Unchanged []string
}

// ComputeDiff compares old and new manifests to determine what actions are needed
func ComputeDiff(oldEntries, newEntries []ManifestEntry) DiffResult {
	result := DiffResult{}

	// Build maps for efficient lookup
	oldMap := make(map[string]string) // path -> hash
	for _, e := range oldEntries {
		oldMap[e.Path] = e.ContentHash
	}

	newMap := make(map[string]string) // path -> hash
	for _, e := range newEntries {
		newMap[e.Path] = e.ContentHash
	}

	// Find orphaned files (in old but not in new)
	for path := range oldMap {
		if _, exists := newMap[path]; !exists {
			result.Orphaned = append(result.Orphaned, path)
		}
	}

	// Categorize new files
	for path, newHash := range newMap {
		if oldHash, exists := oldMap[path]; exists {
			if oldHash == newHash {
				result.Unchanged = append(result.Unchanged, path)
			} else {
				result.Modified = append(result.Modified, path)
			}
		} else {
			result.Created = append(result.Created, path)
		}
	}

	return result
}

// ApplyDiff applies the diff result to the output directory:
// - Deletes orphaned files
// - Writes created and modified files from the source directory
// - Skips unchanged files
// Returns the number of files written and deleted
//
// SECURITY: All paths are validated before any file operation to prevent
// path traversal attacks. Files can only be deleted/written within outputDir.
func ApplyDiff(diff DiffResult, sourceDir, outputDir string) (written int, deleted int, err error) {
	// Delete orphaned files
	for _, relPath := range diff.Orphaned {
		// SECURITY: Full validation before deletion (relPath is from manifest)
		if err := ValidateRelativePathIn(relPath, outputDir); err != nil {
			slog.Error("Refusing to delete file with unsafe path", "path", relPath, "error", err)
			return written, deleted, fmt.Errorf("unsafe path in orphaned files: %w", err)
		}

		fullPath := filepath.Join(outputDir, relPath)
		slog.Info("Deleting orphaned file", "path", relPath)
		if err := os.Remove(fullPath); err != nil {
			if !os.IsNotExist(err) {
				return written, deleted, fmt.Errorf("failed to delete orphaned file %s: %w", fullPath, err)
			}
			// File didn't exist, don't count as deleted
		} else {
			deleted++
		}

		// Try to remove empty parent directories
		cleanupEmptyParentDirs(filepath.Dir(fullPath), outputDir)
	}

	// Write created files
	for _, relPath := range diff.Created {
		// SECURITY: Full validation before writing (relPath is from manifest)
		if err := ValidateRelativePathIn(relPath, outputDir); err != nil {
			slog.Error("Refusing to write file with unsafe path", "path", relPath, "error", err)
			return written, deleted, fmt.Errorf("unsafe path in created files: %w", err)
		}

		if err := copyFileForManifest(sourceDir, outputDir, relPath); err != nil {
			return written, deleted, err
		}
		written++
		slog.Debug("Created new file", "path", relPath)
	}

	// Write modified files
	for _, relPath := range diff.Modified {
		// SECURITY: Full validation before writing (relPath is from manifest)
		if err := ValidateRelativePathIn(relPath, outputDir); err != nil {
			slog.Error("Refusing to write file with unsafe path", "path", relPath, "error", err)
			return written, deleted, fmt.Errorf("unsafe path in modified files: %w", err)
		}

		if err := copyFileForManifest(sourceDir, outputDir, relPath); err != nil {
			return written, deleted, err
		}
		written++
		slog.Debug("Updated modified file", "path", relPath)
	}

	// Unchanged files are skipped
	if len(diff.Unchanged) > 0 {
		slog.Debug("Skipped unchanged files", "count", len(diff.Unchanged))
	}

	return written, deleted, nil
}

// copyFileForManifest copies a file from sourceDir to outputDir, preserving the relative path
func copyFileForManifest(sourceDir, outputDir, relPath string) error {
	srcPath := filepath.Join(sourceDir, relPath)
	dstPath := filepath.Join(outputDir, relPath)

	// Read source file
	content, err := os.ReadFile(srcPath)
	if err != nil {
		return fmt.Errorf("failed to read source file %s: %w", srcPath, err)
	}

	// Ensure destination directory exists
	if err := os.MkdirAll(filepath.Dir(dstPath), 0755); err != nil {
		return fmt.Errorf("failed to create directory for %s: %w", dstPath, err)
	}

	// Write destination file
	if err := os.WriteFile(dstPath, content, 0644); err != nil {
		return fmt.Errorf("failed to write file %s: %w", dstPath, err)
	}

	return nil
}

// cleanupEmptyParentDirs removes empty parent directories up to (but not including) stopAt.
//
// SECURITY: Each directory is validated to ensure it's within stopAt before removal.
// Uses centralized boundary checks from path_validation.go.
func cleanupEmptyParentDirs(dir, stopAt string) {
	for dir != stopAt && dir != "." {
		// Stop at filesystem root (cross-platform)
		if IsFilesystemRoot(dir) {
			break
		}

		// SECURITY: Quick containment check for control flow (dir is already processed)
		if !IsContainedIn(dir, stopAt) {
			slog.Warn("Refusing to clean up directory outside boundary",
				"dir", dir, "boundary", stopAt)
			break
		}

		entries, err := os.ReadDir(dir)
		if err != nil || len(entries) > 0 {
			break // Directory not empty or error reading
		}

		if err := os.Remove(dir); err != nil {
			break // Failed to remove, stop trying
		}
		slog.Debug("Removed empty directory", "path", dir)

		dir = filepath.Dir(dir)
	}
}

// RenderWithManifest renders a template and manages file cleanup using manifests.
// It compares the new render output with the previous manifest to:
// - Delete orphaned files (files that were previously generated but aren't anymore)
// - Skip writing unchanged files (content hash matches)
// - Write only new or modified files
//
// Parameters:
//   - templateID: Unique identifier for the Template component (used to track its files)
//   - renderFunc: Function that renders the template to a temporary directory and returns the temp dir path
//   - outputDir: The final output directory where files should be placed
//
// Returns the diff result showing what was created, modified, deleted, and unchanged
func RenderWithManifest(templateID string, renderFunc func() (tempDir string, err error), outputDir string) (*DiffResult, error) {
	store := GetManifestStore()

	// Get the previous manifest for this template
	prevManifest := store.Get(templateID)
	var prevEntries []ManifestEntry
	if prevManifest != nil {
		prevEntries = prevManifest.Files
	}

	// Render to temp directory
	tempDir, err := renderFunc()
	if err != nil {
		return nil, fmt.Errorf("render failed: %w", err)
	}
	defer os.RemoveAll(tempDir)

	// Build manifest from rendered output
	newEntries, err := BuildManifestFromDirectory(tempDir)
	if err != nil {
		return nil, fmt.Errorf("failed to build manifest from rendered output: %w", err)
	}

	// Compute diff
	diff := ComputeDiff(prevEntries, newEntries)

	slog.Info("Manifest diff computed",
		"templateID", templateID,
		"orphaned", len(diff.Orphaned),
		"created", len(diff.Created),
		"modified", len(diff.Modified),
		"unchanged", len(diff.Unchanged),
	)

	// Ensure output directory exists
	if err := os.MkdirAll(outputDir, 0755); err != nil {
		return nil, fmt.Errorf("failed to create output directory: %w", err)
	}

	// Apply diff to output directory
	written, deleted, err := ApplyDiff(diff, tempDir, outputDir)
	if err != nil {
		return nil, fmt.Errorf("failed to apply diff: %w", err)
	}

	slog.Info("Manifest diff applied",
		"templateID", templateID,
		"filesWritten", written,
		"filesDeleted", deleted,
	)

	// Update manifest in store
	store.Set(templateID, &TemplateManifest{
		TemplateID: templateID,
		OutputDir:  outputDir,
		Files:      newEntries,
	})

	return &diff, nil
}

