---
title: <BoilerplateInputs>
---

import { Aside } from '@astrojs/starlight/components';

The `<BoilerplateInputs>` block creates dynamic web forms based on [Gruntwork Boilerplate](https://github.com/gruntwork-io/boilerplate) variable definitions. It's used to collect user input that can then be used in Commands, Checks, or to generate files from templates.

## Basic Usage

### With Template Path

```mdx
<BoilerplateInputs 
    id="terraform-config" 
    templatePath="templates/terraform-vpc" 
/>
```

This loads the `boilerplate.yml` file from `templates/terraform-vpc/boilerplate.yml` (relative to your runbook file).

### With Inline YAML

`````mdx
<BoilerplateInputs id="user-inputs">
```yaml
variables:
  - name: ProjectName
    type: string
    description: Name for your project
    validations: "required"
  - name: Environment
    type: enum
    description: Deployment environment
    options:
      - dev
      - staging
      - production
    default: dev
```
</BoilerplateInputs>
`````

This will render a form with the following fields:
- ProjectName (text input)
- Environment (dropdown select)

## Props

### Required Props

- `id` (string) - Unique identifier for this form (used by Commands/Checks to reference the variables)

### Optional Props

You must provide a set of Boilerplate variables in one of two ways:

1. **`templatePath`** (string) - Path to a directory containing a `boilerplate.yml` file (relative to runbook). Use this when you have a full Boilerplate template. This is the recommended way to use `<BoilerplateInputs>`.

2. **Inline YAML** - Write the YAML directly inside the `<BoilerplateInputs>` tags. Use this to collect values for other blocks (Commands, Checks) without generating files. This is used less frequently.

## Supported Variable Types

### String

Text input field:

```yaml
variables:
  - name: ProjectName
    type: string
    description: Name for your project
    default: my-project
    validations: "required"
```

### Int

Number input field:

```yaml
variables:
  - name: InstanceCount
    type: int
    description: Number of instances
    default: 3
```

### Bool

Checkbox:

```yaml
variables:
  - name: EnableMonitoring
    type: bool
    description: Enable CloudWatch monitoring
    default: true
```

### Enum

Dropdown select:

```yaml
variables:
  - name: Environment
    type: enum
    description: Deployment environment
    options:
      - dev
      - staging
      - production
    default: dev
```

### List

Dynamic list of values:

```yaml
variables:
  - name: AllowedIPs
    type: list
    description: List of allowed IP addresses
    default:
      - 0.0.0.0/0
```

### Map

Key-value pairs:

```yaml
variables:
  - name: Tags
    type: map
    description: AWS resource tags
    default:
      Environment: dev
      Owner: team
```

### Structured Map (with Schema)

<Aside type="note">
The `x-schema` and `x-schema-instance-label` properties are Runbooks extensions and are ignored by Boilerplate itself. See [Runbooks Extensions](#runbooks-extensions) for more details.
</Aside>

Map with predefined fields:

```yaml
variables:
  - name: Accounts
    type: map
    description: AWS accounts configuration
    x-schema:
      email: string
      environment: string
      id: string
    x-schema-instance-label: Account Name
    default:
      dev:
        email: dev@example.com
        environment: development
        id: "123456789012"
      prod:
        email: prod@example.com
        environment: production
        id: "098765432109"
```

## Runbooks Extensions

Runbooks extends Boilerplate's variable syntax with additional properties that enhance the form rendering experience. These properties are prefixed with `x-` to indicate they are Runbooks-specific extensions and will be ignored by Boilerplate itself.

<Aside type="tip">
All Runbooks extension properties start with `x-`. This follows the convention used by OpenAPI and other specifications for vendor extensions. Boilerplate will ignore these properties, so your `boilerplate.yml` files remain compatible with standalone Boilerplate usage.
</Aside>

### x-section

Groups variables under section headers in the rendered form. Variables with the same `x-section` value will be visually grouped together under a collapsible section with a header.

#### Why Use Sections?

When you have just a few variables in your forms, you may not need more than one section. Beyond around 7 variables, it can be tiresome for users to scan an endless list of variables. Humans like to group things to reduce cognitive load, and that's exactly what sections do -- you can define a header for a group of variables, making it easier for users to mentally organize the variables.

#### Basic Example

```yaml
variables:
  # Variables without x-section appear first (ungrouped)
  - name: FunctionName
    type: string
    description: Name for your Lambda function

  # Variables in "Basic Configuration" section
  - name: Runtime
    type: enum
    description: Lambda runtime
    options:
      - python3.12
      - nodejs20.x
    x-section: Basic Configuration

  - name: Handler
    type: string
    description: Function entrypoint
    x-section: Basic Configuration

  # Variables in "Advanced Settings" section  
  - name: MemorySize
    type: int
    description: Memory allocation in MB
    default: 128
    x-section: Advanced Settings

  - name: Timeout
    type: int
    description: Timeout in seconds
    default: 30
    x-section: Advanced Settings
```

This renders as a form with three visual groups:
1. **Ungrouped variables** (no header) - `FunctionName`
2. **Basic Configuration** section - `Runtime`, `Handler`
3. **Advanced Settings** section - `MemorySize`, `Timeout`

#### Ordering Behavior

The ordering of sections and variables follows these rules:

1. **Ungrouped variables always appear first** - Variables without an `x-section` are rendered at the top of the form without a section header
2. **Named sections appear in declaration order** - Sections are displayed in the order they first appear in the YAML (based on the first variable with that section name)
3. **Variables maintain declaration order within sections** - Variables within a section keep their original order from the YAML

<Aside type="tip">
You can interleave variables from different sections in your YAML file - Runbooks will automatically group them by section name while preserving the order within each section.
</Aside>

#### Declaration Order Example

```yaml
variables:
  # "Advanced" section appears first in YAML
  - name: MemorySize
    x-section: Advanced Settings
    
  # Ungrouped variable
  - name: FunctionName

  # "Basic" section appears second
  - name: Runtime
    x-section: Basic Configuration
    
  # Another "Advanced" variable
  - name: Timeout
    x-section: Advanced Settings
```

Despite the interleaved order in YAML, the form renders as:
1. **Ungrouped** - `FunctionName` (ungrouped always first)
2. **Advanced Settings** - `MemorySize`, `Timeout` (appears second because "Advanced" was declared first)
3. **Basic Configuration** - `Runtime` (appears third)

#### Combining with Other Extensions

Sections work well with other Runbooks extensions like `x-schema`:

```yaml
variables:
  - name: FunctionName
    type: string
    description: Lambda function name

  - name: Runtime
    type: enum
    options: [python3.12, nodejs20.x]
    x-section: Basic Configuration

  - name: Tags
    type: map
    description: Resource tags
    x-section: Advanced Settings
    x-schema:
      Name: string
      Environment: string
    x-schema-instance-label: Tag Name

  - name: MemorySize
    type: int
    default: 128
    x-section: Advanced Settings
```

### x-schema

Defines a schema for structured map variables. The frontend renders a form with the specified fields for each map entry.

```yaml
variables:
  - name: AWSAccounts
    type: map
    description: AWS accounts configuration
    x-schema:
      email: string
      environment: string
      id: string
```

### x-schema-instance-label

Customizes the label used for each entry in a structured map (used with `x-schema`).

```yaml
variables:
  - name: AWSAccounts
    type: map
    description: AWS accounts configuration
    x-schema:
      email: string
      environment: string
      id: string
    x-schema-instance-label: Account Name
```

Without this property, map entries would be labeled generically. With `x-schema-instance-label: Account Name`, each entry is labeled as "Account Name" in the form.

## Validations

<Aside type="note">
Some Boilerplate validation types are not supported by Runbooks.
</Aside>

Boilerplate supports various validation types:

```yaml
variables:
  - name: Email
    type: string
    validations:
      - type: required
        message: Email is required
      - type: email
        message: Must be a valid email address

  - name: Region
    type: string
    validations:
      - type: required
      - type: length
        args: [2, 20]
        message: Region must be between 2 and 20 characters

  - name: ProjectName
    type: string
    validations:
      - type: alphanumeric
        message: Project name must be alphanumeric
```

Supported validation types:
- `required` - Field must not be empty
- `email` - Must be a valid email address
- `url` - Must be a valid URL
- `alpha` - Letters only
- `digit` - Numbers only
- `alphanumeric` - Letters and numbers only
- `semver` - Valid semantic version (e.g., 1.2.3)
- `length` - String length range (args: [min, max])
- `countrycode2` - Two-letter country code

## Using with Commands and Checks

### Reference by ID

`````mdx
<BoilerplateInputs id="vpc-config">
```yaml
variables:
  - name: VpcName
    type: string
  - name: CidrBlock
    type: string
    default: 10.0.0.0/16
```
</BoilerplateInputs>

<Command 
    id="create-vpc" 
    command="aws ec2 create-vpc --cidr-block {{ .CidrBlock }} --tag-specifications 'ResourceType=vpc,Tags=[{Key=Name,Value={{ .VpcName }}}]'"
    inputsId="vpc-config"
    title="Create VPC"
/>
`````

### Reference Multiple IDs

You can reference multiple BoilerplateInputs by passing an array of IDs. Variables are merged in order, with later IDs overriding earlier ones:

`````mdx
<BoilerplateInputs id="lambda-config" templatePath="templates/lambda" />

<BoilerplateInputs id="repo-config">
```yaml
variables:
  - name: GithubOrgName
    type: string
  - name: GithubRepoName
    type: string
```
</BoilerplateInputs>

<Command 
    id="deploy" 
    path="scripts/deploy.sh"
    inputsId={["lambda-config", "repo-config"]}
    title="Deploy"
/>
`````

This is useful when you have variables defined in different forms that all need to be available in a single Command or Check.

### Inline (Embedded)

`````mdx
<Command 
    id="echo-greeting" 
    command='echo "Hello, {{ .Name }}!"'
>
    <BoilerplateInputs id="inline-name">
    ```yaml
    variables:
      - name: Name
        type: string
        description: Your name
    ```
    </BoilerplateInputs>
</Command>
`````

## Generating Files

When you provide a `templatePath`, users can click "Generate" to create files from templates using Boilerplate:

```mdx
<BoilerplateInputs 
    id="vpc-template" 
    templatePath="templates/vpc" 
/>
```

Directory structure:
```
templates/vpc/
├── boilerplate.yml
├── main.tf
├── variables.tf
└── outputs.tf
```

The template files can use Boilerplate syntax:
```hcl
# main.tf
resource "aws_vpc" "main" {
  cidr_block = "{{ .CidrBlock }}"
  
  tags = {
    Name = "{{ .VpcName }}"
    Environment = "{{ .Environment }}"
  }
}
```

Generated files are saved to a `generated/` directory by default (or the path specified with the `--output-path` CLI flag) and displayed in a file tree in the UI.

## Form Features

### Auto-Render

When used inline with Commands/Checks, the form automatically re-renders the command/check as the user types (with debouncing).

### Generate Button

For standalone BoilerplateInputs with a `templatePath`, a "Generate" button appears. Clicking it:
1. Validates all form inputs
2. Calls the backend API to render the template
3. Displays a file tree of generated files
4. Shows a success indicator

### Form Validation

The form validates inputs in real-time based on the validation rules defined in the boilerplate.yml.

## Complete Example

```mdx
# Deploy a VPC

First, configure your VPC settings:

<BoilerplateInputs id="vpc-setup" templatePath="templates/vpc" />

The form above will generate Terraform files. Now let's validate and apply:

<Check 
    id="validate-terraform" 
    command="cd generated && terraform validate"
    title="Validate Terraform Configuration"
    successMessage="Terraform configuration is valid!"
/>

<Command 
    id="apply-terraform" 
    command="cd generated && terraform init && terraform apply -auto-approve"
    title="Deploy VPC"
    successMessage="VPC deployed successfully!"
    failMessage="VPC deployment failed. Check logs."
/>

<Check 
    id="verify-vpc" 
    command="aws ec2 describe-vpcs --filters Name=tag:Name,Values={{ .VpcName }}"
    inputsId="vpc-setup"
    title="Verify VPC Was Created"
    successMessage="VPC exists!"
/>
```
