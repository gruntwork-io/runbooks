---
title: <GitHubAuth>
---

import { Aside } from '@astrojs/starlight/components';

The `<GitHubAuth>` block provides a streamlined interface for authenticating to GitHub. 

It automatically detects if the user is already authenticated to GitHub by checking their local environment variables or the GitHub CLI status. It also enables users to authenticate manually via OAuth or by entering a Personal Access Token (PAT). Once authenticated, GitHub credentials are automatically available to subsequent [Command](/authoring/blocks/command/) and [Check](/authoring/blocks/check/) blocks.

You can still authenticate to GitHub without this block by using Runbooks' support for environment variables, however this is the recommended way to authenticate to GitHub in Runbooks.

### Basic Usage

```mdx
<GitHubAuth
  id="gh-auth"
  title="Authenticate to GitHub"
  description="Sign in to access private repositories"
/>

<Command
  id="clone-repo"
  githubAuthId="gh-auth"
  title="Clone Repository"
  command="git clone https://github.com/gruntwork-io/runbooks.git"
/>
```

By default, Runbooks will automatically detect and use credentials from:
1. Environment variables (`GITHUB_TOKEN` or `GH_TOKEN`)
2. GitHub CLI (`gh auth token`)

If no credentials are detected, users can authenticate manually via OAuth or PAT.

### Authentication Methods

The GitHubAuth block supports multiple authentication sources:

| Method | Description | 
|--------|-------------|
| **Environment Variable** | Auto-detected from `GITHUB_TOKEN`, `GH_TOKEN`, or a user-specified value |
| **GitHub CLI** | Auto-detected from `gh auth token` |
| **OAuth** | Sign in via GitHub's device authorization flow (recommended) |
| **Personal Access Token** | Enter a PAT (classic or fine-grained) directly in the UI | 

### GitHub Enterprise Support

The GitHubAuth block supports GitHub.com, GitHub Enterprise Cloud and GitHub Enterprise Server. However, OAuth is only supported for GitHub.com and GitHub Enterprise Cloud. For GitHub Enterprise Server, you can use PAT authentication or contact Gruntwork for enterprise support options.

## Props

| Prop | Type | Default | Description |
|------|------|---------|-------------|
| `id` | string | required | Unique identifier for this component |
| `title` | string | "GitHub Authentication" | Display title shown in the UI |
| `description` | string | - | Description of the authentication purpose |
| `detectCredentials` | `false` or `CredentialSource[]` | `['env', 'cli']` | Whether and how the block should automatically detect credentials in the user's environment |
| `oauthClientId` | string | Gruntwork default | Custom OAuth App client ID |
| `oauthScopes` | string[] | `["repo"]` | OAuth scopes to request |

## Usage

When authentication succeeds, the following environment variables are set in the session:

| Variable | Description |
|----------|-------------|
| `GITHUB_TOKEN` | The GitHub access token |
| `GITHUB_USER` | The authenticated user's login name |

All subsequent Command and Check blocks automatically have access to these credentials. If you authenticate multiple times, the most recent credentials become the default.

### Explicit References

You can explicitly reference a GitHubAuth block using the `githubAuthId` prop. This is useful when:
- You have multiple GitHubAuth blocks and need to use a specific one
- You want to document the dependency clearly

```mdx
<GitHubAuth
  id="gh-auth"
  title="Authenticate to GitHub"
/>

<Check
  id="verify-auth"
  title="Verify GitHub Access"
  command="gh auth status"
  githubAuthId="gh-auth"
  successMessage="Successfully authenticated!"
/>

<Command
  id="clone-repo"
  title="Clone Repository"
  command="git clone https://github.com/org/repo.git"
  githubAuthId="gh-auth"
  successMessage="Repository cloned!"
/>
```

<Aside type="tip">
Using `githubAuthId` is optional when you only have one GitHubAuth block, but it makes the dependency explicit and helps with automated testing.
</Aside>

### Credential Detection

By default, GitHubAuth automatically detects existing credentials from environment variables and GitHub CLI. You can customize this behavior with the `detectCredentials` prop.

#### Default Behavior

With no configuration, GitHubAuth tries these sources in order:

```mdx
{/* Default - same as detectCredentials={['env', 'cli']} */}
<GitHubAuth id="gh-auth" />
```

1. **Environment variables** - `GITHUB_TOKEN` or `GH_TOKEN`
2. **GitHub CLI** - `gh auth token`

If either source provides valid credentials, authentication succeeds immediately. If neither is found, users see the manual OAuth/PAT interface.

#### Detection Sources

| Source | Description |
|--------|-------------|
| `'env'` | Check standard env vars (`GITHUB_TOKEN`, `GH_TOKEN`) |
| `'cli'` | Check GitHub CLI (`gh auth token`) |
| `{ env: 'VAR_NAME' }` | Check a specific env var |
| `{ block: 'block-id' }` | Use token from a Command block's output |

#### Custom Detection Order

Check only environment variables:

```mdx
<GitHubAuth
  id="gh-auth"
  detectCredentials={['env']}
/>
```

Check a specific env var first, then standard locations:

```mdx
<GitHubAuth
  id="gh-auth"
  detectCredentials={[{ env: 'MY_GITHUB_TOKEN' }, 'env', 'cli']}
/>
```

#### Disable Auto-Detection

Force manual authentication only:

```mdx
<GitHubAuth
  id="gh-auth"
  detectCredentials={false}
/>
```

#### From Command Output

Use a token generated by a previous Command block:

```mdx
<Command
  id="fetch-token"
  path="scripts/get-token.sh"
  title="Fetch GitHub Token"
/>

<GitHubAuth
  id="dynamic-auth"
  title="GitHub Access"
  detectCredentials={[{ block: 'fetch-token' }]}
/>
```

The Command script should output the token:

```bash
#!/bin/bash
# Example: fetch token from a secrets manager
TOKEN=$(vault read -field=token secret/github)
echo "GITHUB_TOKEN=$TOKEN" >> "$RUNBOOK_OUTPUT"
```

## Permissions

Once authenticated to GitHub, Runbooks will update the environment variables `GITHUB_TOKEN` and `GITHUB_USER` with the authenticated user's token and username. GitHub tokens have permissions that control what actions they can perform. The way permissions are configured depends on the authentication method:

| Method | How Permissions Are Set |
|--------|------------------------|
| **Environment Variable** | Permissions are inherited from however the token was originally created |
| **GitHub CLI** | Permissions are inherited from `gh auth login`; Runbooks warns if `repo` scope is missing |
| **OAuth** | Runbook author specifies OAuth scopes via `oauthScopes` prop; user approves on GitHub |
| **Personal Access Token (PAT)** | User configures permissions when creating the token on GitHub |

### OAuth Scopes

When users authenticate via OAuth, the `oauthScopes` prop controls what permissions are requested. Users see these scopes on GitHub's authorization page and must approve them.

The default is `["repo"]`, which grants full read/write access to repositories. Consider requesting fewer permissions if your runbook has limited needs:

| Scope | Description |
|-------|-------------|
| `repo` | Full access to private and public repositories (default) |
| `public_repo` | Access to public repositories only |
| `repo:status` | Read/write commit status (useful for CI) |
| `read:org` | Read organization membership |

For a complete list, see [GitHub's OAuth scopes documentation](https://docs.github.com/en/apps/oauth-apps/building-oauth-apps/scopes-for-oauth-apps).

```mdx
<GitHubAuth
  id="gh-auth"
  title="Limited GitHub Access"
  oauthScopes={["public_repo", "read:org"]}
/>
```

<Aside type="caution">
OAuth permissions are coarse-grained, and the minimum viable OAuth scope that Runbooks can use is `repo`, which grants full read/write access to all repositories and is still quite permissive. If you want to narrow down the permissions, consider defining a fine-grained token and using it as an environment variable, or manually entering it into the UI.
</Aside>

### Personal Access Tokens

When users authenticate with a PAT, the token's permissions are determined by how the user created it on GitHub. Runbook authors cannot control PAT permissions.

- **Classic PATs** use the same scope system as OAuth (e.g., `repo`, `read:org`)
- **Fine-grained PATs** offer more granular control per-repository

If your runbook requires specific permissions, document them clearly so users know what to configure when creating their PAT.

### Auto-detected credentials

When GitHubAuth detects credentials from environment variables or GitHub CLI, those tokens retain whatever permissions they were originally created with. If a detected token lacks required permissions, operations may fail at runtime.

<Aside type="note">
When detecting credentials from GitHub CLI, Runbooks checks if the token has the `repo` scope and displays a warning if it's missing, since many common operations require it.
</Aside>

## Security

### How OAuth Authentication Works

When you authenticate via OAuth, GitHubAuth uses the [Device Authorization Grant](https://docs.github.com/en/apps/oauth-apps/building-oauth-apps/authorizing-oauth-apps#device-flow):

1. Runbooks (on your machine) requests a device code from GitHub
2. You open github.com/login/device and enter the code
3. You see "Gruntwork Runbooks wants to access your account" and approve
4. Your local Runbooks instance receives the token directly from GitHub

Importantly, your token never passes through any Gruntwork server. It goes directly from GitHub to your local machine.

### Attack Vector Analysis

#### 1. Malicious Runbook with Custom `oauthClientId`

**Scenario**: A malicious runbook author publishes a runbook with `oauthClientId="attacker-app-id"`.

**What happens**:
- You see "Attacker's App" (not "Gruntwork Runbooks") on GitHub's authorization page
- If you approve, the token still goes to YOUR local machine, not the attacker
- The attacker registered an OAuth app but has no server receiving tokens

**Risk**: Low. The attacker cannot intercept your token.

**Impact**: Minimal. You authorized a differently-named app, but the attacker has no way to access your token.

**Mitigation**: Runbooks shows a warning when `oauthClientId` differs from the default. Always verify the app name on GitHub's authorization page matches what you expect.

#### 2. Malicious Runbook with Custom Base URL

**Risk**: None - this attack is blocked.

We do NOT allow `oauthBaseUrl` as a runbook prop. GitHubAuth only communicates with github.com. This prevents phishing attacks where a malicious runbook could redirect OAuth to a fake GitHub login page.

#### 3. Scope Escalation via Runbook

**Scenario**: A runbook author sets `oauthScopes={["repo", "admin:org", "delete_repo"]}` requesting excessive permissions.

**What happens**: GitHub's authorization page shows all requested scopes. If you approve without reading carefully, you grant broader access than needed.

**Risk**: Medium. Depends on user vigilance.

**Mitigation**: Always review the scope list on GitHub's authorization page before approving. Default is `["repo"]` which is sufficient for most operations. Be suspicious of runbooks requesting `admin:*`, `delete_repo`, or `write:*` scopes.

### Security Best Practices

1. **Review the authorization page** - Verify it says "Gruntwork Runbooks" and shows expected scopes
2. **Check runbook source** - Before running unfamiliar runbooks, review the GitHubAuth props
3. **Use OAuth over PAT** - OAuth tokens can be scoped and are easier to revoke
4. **Revoke unused authorizations** - Manage at github.com/settings/applications

### Verifying Your Authorization

After authenticating, you can verify and manage the authorization at:
- https://github.com/settings/applications - See authorized OAuth apps
- https://github.com/settings/tokens - See active tokens (for PAT auth)

You can revoke access at any time from these pages.
