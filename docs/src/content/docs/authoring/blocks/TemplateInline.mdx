---
title: <TemplateInline>
---

import { Aside } from '@astrojs/starlight/components';

The `<TemplateInline>` block renders Boilerplate templates directly in your runbook, displaying the rendered output inline. Unlike `<Template>`, which loads templates from a directory, `<TemplateInline>` lets you write template content directly in your runbook file.

## Basic Usage

`````mdx
<Inputs id="greeting">
```yaml
variables:
  - name: Name
    type: string
    default: World
```
</Inputs>

<TemplateInline inputsId="greeting" outputPath="hello.txt">
```txt
Hello, {{ .Name }}!
```
</TemplateInline>
`````

## vs. Template

TemplateInline and [Template](/authoring/blocks/template/) both render Boilerplate templates, but they serve different purposes:

| Feature | `<TemplateInline>` | `<Template>` |
|---------|-------------------|--------------|
| Template source | Inline in runbook | Directory with `boilerplate.yml` |
| Form rendered | No (uses [Inputs](/authoring/blocks/inputs/)) | Yes, from `boilerplate.yml` |
| File generation | Optional (`generateFile={true}`) | Always saves to workspace |
| Use case | Show preview of single files inline | Generate files from template directories |

Use `<TemplateInline>` when you want to show users what generated content looks like inline, or for quick single-file templates. Use `<Template>` when you have a full Boilerplate template directory with multiple files and a `boilerplate.yml` configuration.

## Props

### Required Props

- **[Inline template content]** - The template content to render, written as a fenced code block inside the `<TemplateInline>` tags. The code block should include a language hint (e.g., `hcl`, `yaml`, `dockerfile`) for syntax highlighting.

### Optional Props

- `inputsId` (string | string[]) - ID of the Inputs block(s) to get variable values from. When multiple IDs are provided as an array, variables are merged in order (later IDs override earlier ones). If not provided, the template renders without variable substitution.
- `outputPath` (string) - File path to display for the rendered output (e.g., `config.yaml`). This appears as the filename in the code block header.
- `generateFile` (boolean) - Whether to add the rendered file to the file tree. When `false` (the default), the template is preview-only and displays inline. Set to `true` to also save the rendered file to the workspace.

<Aside type="note">
For security reasons, `outputPath` must be a relative path. Absolute paths and directory traversal attempts (e.g., `../`) are blocked.
</Aside>

## With Variables

There are several ways to provide variables to a TemplateInline.

### Using inputsId

Reference a separate Inputs block to get variable values:

`````mdx
<Inputs id="docker-config">
```yaml
variables:
  - name: AppName
    type: string
  - name: NodeVersion
    type: string
    default: "18"
```
</Inputs>

<TemplateInline inputsId="docker-config" outputPath="Dockerfile">
```dockerfile
FROM node:{{ .NodeVersion }}-alpine

WORKDIR /app
COPY package*.json ./
RUN npm install
COPY . .

EXPOSE 3000
CMD ["node", "server.js"]
```
</TemplateInline>
`````

### Using Multiple inputsIds

You can reference multiple Inputs blocks by passing an array of IDs. Variables are merged in order, with later IDs overriding earlier ones:

`````mdx
<Inputs id="global-config">
```yaml
variables:
  - name: Environment
    type: enum
    options: [dev, staging, prod]
    default: dev
```
</Inputs>

<Inputs id="service-config">
```yaml
variables:
  - name: ServiceName
    type: string
  - name: Port
    type: int
    default: 8080
```
</Inputs>

<TemplateInline inputsId={["global-config", "service-config"]} outputPath="deploy.tf">
```hcl
resource "aws_ecs_service" "main" {
  name = "{{ .ServiceName }}-{{ .Environment }}"
  
  load_balancer {
    container_port = {{ .Port }}
  }
}
```
</TemplateInline>
`````

In this example, the template has access to variables from both Inputs blocks.

## Multiple Files

You can have multiple `<TemplateInline>` blocks referencing the same `<Inputs>`:

`````mdx
<Inputs id="app-config">
```yaml
variables:
  - name: AppName
    type: string
  - name: Environment
    type: enum
    options: [dev, prod]
```
</Inputs>

<TemplateInline inputsId="app-config" outputPath="config.yaml">
```yaml
app:
  name: {{ .AppName }}
  environment: {{ .Environment }}
```
</TemplateInline>

<TemplateInline inputsId="app-config" outputPath=".env">
```bash
APP_NAME={{ .AppName }}
ENVIRONMENT={{ .Environment }}
```
</TemplateInline>
`````

## With Boilerplate Logic

You can use full Boilerplate template syntax including conditionals and loops:

`````mdx
<Inputs id="terraform-config">
```yaml
variables:
  - name: Environment
    type: enum
    options: [dev, prod]
  - name: EnableMonitoring
    type: bool
    default: false
```
</Inputs>

<TemplateInline inputsId="terraform-config" outputPath="main.tf">
```hcl
resource "aws_instance" "app" {
  ami           = "ami-12345678"
  instance_type = "{{ if eq .Environment "prod" }}t3.large{{ else }}t3.micro{{ end }}"

  {{- if .EnableMonitoring }}
  monitoring = true
  {{- end }}
}
```
</TemplateInline>
`````

For full details on template syntax, see [Boilerplate Template Syntax](/authoring/boilerplate/#template-syntax).

## Using Block Outputs

TemplateInline can reference outputs from [Command](/authoring/blocks/command/) or [Check](/authoring/blocks/check/) blocks that have already run. This allows you to display dynamic values produced by previous steps in your rendered templates.

### Output Syntax

Access block outputs using the `_blocks` namespace:

`````mdx
<TemplateInline inputsId="config" outputPath="backend.tf">
```hcl
# Values from the create-account Command
provider "aws" {
  region = "{{ ._blocks.create_account.outputs.region }}"
}

resource "aws_iam_account_alias" "alias" {
  account_alias = "my-org-{{ ._blocks.create_account.outputs.account_id }}"
}
```
</TemplateInline>
`````

<Aside type="note">
**ID Naming:** You can use hyphens or underscores in your block IDs (e.g., `id="create-account"` or `id="create_account"`). 
In template syntax, always use underscores: `._blocks.create_account`. This is because Go templates interpret hyphens as the subtraction operator.

Note: IDs that would normalize to the same value (e.g., `create-account` and `create_account`) cannot coexist in the same runbook.
</Aside>

### Output Dependencies

When a TemplateInline component renders, it automatically scans the template content for `{{ ._blocks.*.outputs.* }}` patterns. If those outputs don't exist yet:

1. A warning is displayed showing which blocks need to run first
2. The template remains in a "waiting" state until the required blocks have executed

### Example: Displaying Command Outputs

`````mdx
## Step 1: Create Account

<Command 
  id="create-account" 
  path="scripts/create-account.sh"
  title="Create AWS Account"
/>

## Step 2: View Generated Configuration

This shows what your configuration will look like:

<TemplateInline outputPath="account-info.txt">
```txt
Account ID: {{ ._blocks.create_account.outputs.account_id }}
Region:     {{ ._blocks.create_account.outputs.region }}
```
</TemplateInline>
`````

### Combining Inputs and Outputs

You can use both standard inputs (from `<Inputs>` blocks) and block outputs in the same template:

`````mdx
<Inputs id="config">
```yaml
variables:
  - name: Environment
    type: string
    default: production
```
</Inputs>

<TemplateInline inputsId="config" outputPath="config.yaml">
```yaml
# From Inputs block
environment: {{ .Environment }}

# From Command outputs
account_id: {{ ._blocks.create_account.outputs.account_id }}
```
</TemplateInline>
`````

<Aside type="tip" title="See It in Action">
Check out the [block-outputs feature demo](https://github.com/gruntwork-io/runbooks/tree/main/testdata/feature-demos/block-outputs) for a complete working demonstration of TemplateInline blocks that consume outputs from upstream Command blocks, including examples of iterating over lists and maps.
</Aside>

## Generating Files

By default, `<TemplateInline>` is preview-onlyâ€”it shows the rendered output but doesn't save files. To also save the rendered content to the generated files workspace, set `generateFile={true}`:

`````mdx
<Inputs id="config">
```yaml
variables:
  - name: ProjectName
    type: string
```
</Inputs>

<TemplateInline 
  inputsId="config" 
  outputPath="README.md"
  generateFile={true}
>
```markdown
# {{ .ProjectName }}

Welcome to {{ .ProjectName }}!
```
</TemplateInline>
`````

<Aside type="tip">
Use `generateFile={true}` when you want users to both see the output inline _and_ have the file saved to their workspace.
</Aside>

## Complete Example

Here's a complete example showing `<Inputs>` with multiple `<TemplateInline>` blocks:

`````mdx
# Configure Your Docker Service

Enter your service configuration:

<Inputs id="service-config">
```yaml
variables:
  - name: ServiceName
    type: string
    description: Name of your service
    validations: "required"
  - name: Port
    type: int
    description: Port to expose
    default: 8080
  - name: Environment
    type: enum
    description: Deployment environment
    options: [dev, staging, prod]
    default: dev
```
</Inputs>

Here's what your Docker Compose file will look like:

<TemplateInline inputsId="service-config" outputPath="docker-compose.yaml" generateFile={true}>
```yaml
version: "3.8"
services:
  {{ .ServiceName }}:
    build: .
    ports:
      - "{{ .Port }}:{{ .Port }}"
    environment:
      - NODE_ENV={{ .Environment }}
```
</TemplateInline>

And your environment file:

<TemplateInline inputsId="service-config" outputPath=".env" generateFile={true}>
```bash
SERVICE_NAME={{ .ServiceName }}
PORT={{ .Port }}
ENVIRONMENT={{ .Environment }}
```
</TemplateInline>
`````
