---
title: <TemplateInline>
---

import { Aside } from '@astrojs/starlight/components';

The `<TemplateInline>` block renders Boilerplate templates directly in your runbook, displaying the rendered output inline. Unlike `<Template>`, which loads templates from a directory, `<TemplateInline>` lets you write template content directly in your runbook file.

## Basic Usage

`````mdx
<Inputs id="greeting">
```yaml
variables:
  - name: Name
    type: string
    default: World
```
</Inputs>

<TemplateInline inputsId="greeting" outputPath="hello.txt">
```txt
Hello, {{ .Name }}!
```
</TemplateInline>
`````

## vs. Template

TemplateInline and [Template](/authoring/blocks/template/) both render Boilerplate templates, but they serve different purposes:

| Feature | `<TemplateInline>` | `<Template>` |
|---------|-------------------|--------------|
| Template source | Inline in runbook | Directory with `boilerplate.yml` |
| Form rendered | No (uses [Inputs](/authoring/blocks/inputs/)) | Yes, from `boilerplate.yml` |
| File generation | Optional (`generateFile={true}`) | Always saves to workspace |
| Use case | Show preview of single files inline | Generate files from template directories |

Use `<TemplateInline>` when you want to show users what generated content looks like inline, or for quick single-file templates. Use `<Template>` when you have a full Boilerplate template directory with multiple files and a `boilerplate.yml` configuration.

## Props

### Required Props

- **[Inline template content]** - The template content to render, written as a fenced code block inside the `<TemplateInline>` tags. The code block should include a language hint (e.g., `hcl`, `yaml`, `dockerfile`) for syntax highlighting.

### Optional Props

- `inputsId` (string | string[]) - ID of the Inputs block(s) to get variable values from. When multiple IDs are provided as an array, variables are merged in order (later IDs override earlier ones). If not provided, the template renders without variable substitution.
- `outputPath` (string) - File path to display for the rendered output (e.g., `config.yaml`). This appears as the filename in the code block header.
- `generateFile` (boolean) - Whether to add the rendered file to the file tree. When `false` (the default), the template is preview-only and displays inline. Set to `true` to also save the rendered file to the workspace.
- `target` (`"generated"` | `"worktree"`) - Where template output is written when `generateFile={true}`. Defaults to `"generated"`, which writes to the standard generated files directory (`$GENERATED_FILES`). Set to `"worktree"` to write directly into the active git worktree (the most recently cloned repo via `<GitClone>`). Requires a `<GitClone>` block to have run first.

<Aside type="note">
For security reasons, `outputPath` must be a relative path. Absolute paths and directory traversal attempts (e.g., `../`) are blocked.
</Aside>

## With Variables

There are several ways to provide variables to a TemplateInline.

### Using inputsId

Reference a separate Inputs block to get variable values:

`````mdx
<Inputs id="docker-config">
```yaml
variables:
  - name: AppName
    type: string
  - name: NodeVersion
    type: string
    default: "18"
```
</Inputs>

<TemplateInline inputsId="docker-config" outputPath="Dockerfile">
```dockerfile
FROM node:{{ .NodeVersion }}-alpine

WORKDIR /app
COPY package*.json ./
RUN npm install
COPY . .

EXPOSE 3000
CMD ["node", "server.js"]
```
</TemplateInline>
`````

### Using Multiple inputsIds

You can reference multiple Inputs blocks by passing an array of IDs. Variables are merged in order, with later IDs overriding earlier ones:

`````mdx
<Inputs id="global-config">
```yaml
variables:
  - name: Environment
    type: enum
    options: [dev, staging, prod]
    default: dev
```
</Inputs>

<Inputs id="service-config">
```yaml
variables:
  - name: ServiceName
    type: string
  - name: Port
    type: int
    default: 8080
```
</Inputs>

<TemplateInline inputsId={["global-config", "service-config"]} outputPath="deploy.tf">
```hcl
resource "aws_ecs_service" "main" {
  name = "{{ .ServiceName }}-{{ .Environment }}"
  
  load_balancer {
    container_port = {{ .Port }}
  }
}
```
</TemplateInline>
`````

In this example, the template has access to variables from both Inputs blocks.

## Multiple Files

You can have multiple `<TemplateInline>` blocks referencing the same `<Inputs>`:

`````mdx
<Inputs id="app-config">
```yaml
variables:
  - name: AppName
    type: string
  - name: Environment
    type: enum
    options: [dev, prod]
```
</Inputs>

<TemplateInline inputsId="app-config" outputPath="config.yaml">
```yaml
app:
  name: {{ .AppName }}
  environment: {{ .Environment }}
```
</TemplateInline>

<TemplateInline inputsId="app-config" outputPath=".env">
```bash
APP_NAME={{ .AppName }}
ENVIRONMENT={{ .Environment }}
```
</TemplateInline>
`````

## With Boilerplate Logic

You can use full Boilerplate template syntax including conditionals and loops:

`````mdx
<Inputs id="terraform-config">
```yaml
variables:
  - name: Environment
    type: enum
    options: [dev, prod]
  - name: EnableMonitoring
    type: bool
    default: false
```
</Inputs>

<TemplateInline inputsId="terraform-config" outputPath="main.tf">
```hcl
resource "aws_instance" "app" {
  ami           = "ami-12345678"
  instance_type = "{{ if eq .Environment "prod" }}t3.large{{ else }}t3.micro{{ end }}"

  {{- if .EnableMonitoring }}
  monitoring = true
  {{- end }}
}
```
</TemplateInline>
`````

For full details on template syntax, see [Boilerplate Template Syntax](/authoring/boilerplate/#template-syntax).

## Using Block Outputs

TemplateInline can reference outputs from [Command](/authoring/blocks/command/) or [Check](/authoring/blocks/check/) blocks using the `_blocks` namespace:

`````mdx
<TemplateInline outputPath="account-info.txt">
```txt
Account ID: {{ ._blocks.create_account.outputs.account_id }}
Region:     {{ ._blocks.create_account.outputs.region }}
```
</TemplateInline>
`````

Runbooks scans the template content for output references and shows a warning until all upstream blocks have run.

For the full guide on producing outputs, consuming them, dependency behavior, and ID naming rules, see [Inputs & Outputs — Block Outputs](/authoring/inputs-and-outputs/#block-outputs).

## Generating Files

By default, `<TemplateInline>` is preview-only—it shows the rendered output but doesn't save files. To also save the rendered content to the generated files workspace, set `generateFile={true}`:

`````mdx
<Inputs id="config">
```yaml
variables:
  - name: ProjectName
    type: string
```
</Inputs>

<TemplateInline 
  inputsId="config" 
  outputPath="README.md"
  generateFile={true}
>
```markdown
# {{ .ProjectName }}

Welcome to {{ .ProjectName }}!
```
</TemplateInline>
`````

<Aside type="tip">
Use `generateFile={true}` when you want users to both see the output inline _and_ have the file saved to their workspace.
</Aside>

## Block IDs for Testing

Unlike `<Check>` and `<Command>` blocks, `<TemplateInline>` blocks don't have an explicit `id` prop. Instead, IDs are **auto-generated** based on the `outputPath` prop. The auto-generated ID is used in the test framework to reference the block.

Learn more about how to use block IDs in the [testing documentation](/authoring/testing/#block-ids).

## Complete Example

Here's a complete example showing `<Inputs>` with multiple `<TemplateInline>` blocks:

`````mdx
# Configure Your Docker Service

Enter your service configuration:

<Inputs id="service-config">
```yaml
variables:
  - name: ServiceName
    type: string
    description: Name of your service
    validations: "required"
  - name: Port
    type: int
    description: Port to expose
    default: 8080
  - name: Environment
    type: enum
    description: Deployment environment
    options: [dev, staging, prod]
    default: dev
```
</Inputs>

Here's what your Docker Compose file will look like:

<TemplateInline inputsId="service-config" outputPath="docker-compose.yaml" generateFile={true}>
```yaml
version: "3.8"
services:
  {{ .ServiceName }}:
    build: .
    ports:
      - "{{ .Port }}:{{ .Port }}"
    environment:
      - NODE_ENV={{ .Environment }}
```
</TemplateInline>

And your environment file:

<TemplateInline inputsId="service-config" outputPath=".env" generateFile={true}>
```bash
SERVICE_NAME={{ .ServiceName }}
PORT={{ .Port }}
ENVIRONMENT={{ .Environment }}
```
</TemplateInline>
`````
