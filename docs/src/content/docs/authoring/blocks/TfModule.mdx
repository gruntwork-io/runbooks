---
title: <TfModule>
---

import { Aside } from '@astrojs/starlight/components';

The `<TfModule>` block parses an OpenTofu/Terraform module, dynamically renders a web form to collect values for all the module's variables, and publishes the collected values to the runbooks global context.

This is useful because blocks like [`<Template>`](/authoring/blocks/template/) and [`<TemplateInline>`](/authoring/blocks/templateinline/) can read these values to generate any output format, such as a Terragrunt HCL file, Helm chart YAML file, CloudFormation template, or anything else.

You can also use the `runbooks open` (or `watch` or `serve`) commands to open a URL containing an OpenTofu/Terraform module and dynamically render a web form within a customizable runbook to collect values for the module's variables. For example:

```bash
runbooks open https://github.com/gruntwork-io/runbooks/tree/main/testdata/test-fixtures/tofu-modules/s3-bucket
```

Effectively, this means you can define a runbook that unblocks a web-based self-service experience for your entire existing collection of OpenTofu/Terraform modules.

## Basic Usage

`````mdx
<TfModule id="rds-vars" source="../modules/rds" />

<Template id="rds-output" inputsId="rds-vars" path="templates/rds" />
`````

The `<TfModule>` block parses the `.tf` files at `../modules/rds` and renders a web form based on them. The `<Template>` block imports those values via `inputsId` and generates files based on the the template located at `templates/rds`.

<Aside type="tip">
For quick prototyping you can also use [`<TemplateInline>`](/authoring/blocks/templateinline/) to embed template text directly in the runbook. See [Using TemplateInline](#using-templateinline) below.
</Aside>

## vs. Inputs

Both `<TfModule>` and `<Inputs>` collect user values and publish them to context, but they serve different purposes.

- **`<TfModule>`** parses `.tf` files (OpenTofu/Terraform modules) at runtime and auto-generates an input form from the module's variables. It provides a `_module` namespace with source, metadata, `inputs`, and `hcl_inputs`, enabling dynamic iteration over all variables without knowing their names upfront. Use it when you want to generate files from an existing OpenTofu/Terraform module.
- **`<Inputs>`** defines variables explicitly in inline YAML or a `boilerplate.yml`. Each variable must be referenced by name in templates. Use it when you want to collect arbitrary user input that doesn't come from a `.tf` module.

## Props

### Required Props

- `id` (string) - Unique identifier for this component. Other blocks reference this ID via `inputsId` to access the collected values.
- `source` (string) - Path or URL to the OpenTofu/Terraform module directory containing `.tf` files. See [Supported Source Formats](#supported-source-formats) below.

## Supported Source Formats

The `source` prop accepts the same formats as the `runbooks open` CLI command:

| Format | Example |
|--------|---------|
| Local relative path | `../modules/rds` |
| Colocated (same directory) | `.` |
| Dynamic from CLI | `::cli_runbook_source` |
| GitHub shorthand | `github.com/org/repo//modules/rds?ref=v1.0.0` |
| Git prefix | `git::https://github.com/org/repo.git//modules/rds?ref=v1.0.0` |
| GitHub browser URL | `https://github.com/org/repo/tree/main/modules/rds` |
| GitLab browser URL | `https://gitlab.com/org/repo/-/tree/main/modules/rds` |

<Aside type="tip">
For remote sources, use `?ref=v1.0.0` (or a branch/commit) to pin to a specific version. Without a ref, the default branch is used.
</Aside>

### Colocated Runbooks (`source="."`)

When a module author places a `runbook.mdx` alongside their `.tf` files, they can use `source="."` to reference the module in the same directory. When someone runs `runbooks open` pointing at that directory (locally or via a remote URL), the CLI detects the colocated `runbook.mdx` and serves it instead of auto-generating a basic one.

This lets module authors ship a custom, polished runbook experience alongside their module code:

```
modules/rds/
├── main.tf
├── variables.tf
├── outputs.tf
└── runbook.mdx        ← custom runbook
```

Inside `runbook.mdx`:

`````mdx
# Configure RDS

<TfModule id="rds-vars" source="." />

<TemplateInline inputsId="rds-vars" outputPath="terragrunt.hcl" generateFile={true}>
```hcl
terraform {
  source = "{{ ._module.source }}"
}

inputs = {
{{- range $name, $hcl := ._module.hcl_inputs }}
  {{ $name }} = {{ $hcl }}
{{- end }}
}
```
</TemplateInline>
`````

Anyone can then run this module's custom runbook:

```bash
runbooks open https://github.com/my-org/infra-modules/tree/main/modules/rds
```

### Dynamic Source from CLI (`source="::cli_runbook_source"`)

The `::cli_runbook_source` keyword resolves to whatever URL was passed to the `runbooks open` CLI command (or `runbooks watch` or `runbooks serve`). This enables a **generic runbook** that works with any OpenTofu/Terraform module without hardcoding a specific module path.

Use the `--tf-runbook` flag to tell the CLI to use your custom runbook when opening a TF module:

```bash
runbooks open --tf-runbook ./my-custom-runbook/ https://github.com/org/repo/tree/main/modules/rds
```

Inside `my-custom-runbook/runbook.mdx`:

`````mdx
# Configure Module

<TfModule id="module-vars" source="::cli_runbook_source" />

<TemplateInline inputsId="module-vars" outputPath="terragrunt.hcl" generateFile={true}>
```hcl
terraform {
  source = "{{ ._module.source }}"
}

inputs = {
{{- range $name, $hcl := ._module.hcl_inputs }}
  {{ $name }} = {{ $hcl }}
{{- end }}
}
```
</TemplateInline>
`````

If the runbook is opened without a remote module URL, `<TfModule>` renders a message explaining how to run the runbook with a module URL.

<Aside type="note">
You can also select a built-in template by passing a `::keyword` instead of a path: `--tf-runbook=::tofu`. Available keywords:

- **`::terragrunt`** (default) — Generates a `terragrunt.hcl` file with a `terraform.source` block, an `include "root"` block, and all module variables as inputs.
- **`::terragrunt-github`** — A full GitOps workflow: authenticates to GitHub, clones a repo, lets the user pick a target directory, generates a `terragrunt.hcl` (with only non-default inputs), and opens a pull request.
- **`::tofu`** — Generates a plain `main.tf` file with a `module "this"` block for use with OpenTofu/Terraform directly (without Terragrunt).
</Aside>

## The `_module` Namespace

When `<TfModule>` registers its values, it outputs a `_module` value that is a map of key-value pairs. This enables both iteration over all variables and direct access to specific ones.

You can access the `_module` value in your templates just like any other value, using the `{{ ._module }}` syntax.

### Structure

```
_module:
  source: "github.com/org/repo//modules/rds?ref=v1.0.0"
  folder_name: "rds"
  readme_title: "RDS Module"
  output_names: ["db_endpoint", "db_name", "db_port"]
  resource_names: ["aws_db_instance.this", "aws_db_parameter_group.this", "aws_db_subnet_group.this"]
  inputs:
    instance_class: "db.t3.micro"
    engine_version: "16.3"
    allocated_storage: 20
    multi_az: true
  hcl_inputs:
    instance_class: "\"db.t3.micro\""
    engine_version: "\"16.3\""
    allocated_storage: "20"
    multi_az: "true"
  hcl_inputs_non_default:
    instance_class: "\"db.t3.micro\""
    allocated_storage: "20"
    multi_az: "true"
```

- **`_module.source`:** The module source from the `source` prop. Useful for embedding in generated config.
- **`_module.folder_name`:** Name of the module's containing directory (e.g., `"rds"`).
- **`_module.readme_title`:** The first `# Heading` from the module's README.md, if present. Empty string otherwise.
- **`_module.output_names`:** List of output block names defined in the module (sorted alphabetically).
- **`_module.resource_names`:** List of resource block names as `type.name` (sorted, excludes `data` sources).
- **`_module.inputs`:** Map of all variable names to their raw values as entered by the user. Use when generating non-HCL formats (YAML, JSON, TOML) where you control the formatting.
- **`_module.hcl_inputs`:** Map of all variable names to HCL-formatted string values: strings are quoted, booleans and numbers are raw, lists and maps are JSON-encoded. Use when generating HCL files (Terragrunt, Terraform). Values are pre-formatted with correct HCL quoting.
- **`_module.hcl_inputs_non_default`:** Same as `hcl_inputs`, but only includes variables whose current value differs from the module's declared default. Required variables (no default) are always included. Use for idiomatic Terragrunt where you only declare variables that differ from defaults — Terraform/OpenTofu applies defaults automatically for anything omitted.

## Block Outputs

In addition to the `_module` namespace (which is available via `inputsId`), `<TfModule>` also registers block outputs that can be referenced by downstream blocks using the `{{ ._blocks.<id>.outputs.<key> }}` syntax.

| Output | Description |
|--------|-------------|
| `module_name` | The module's folder name (same as `_module.folder_name`). Useful in `outputPath` expressions for naming generated directories. |
| `source` | The resolved module source URL. |

For example, the `::terragrunt-github` template uses `module_name` to compose the output path:

```
outputPath="{{ ._blocks.target_path.outputs.path }}/{{ ._blocks.module_vars.outputs.module_name }}/terragrunt.hcl"
```

## Variable Grouping

When `<TfModule>` renders the input form, it automatically "groups" variables into collapsible sections. Grouping is purely a UI feature that organizes a set of variables together under a common heading to help reduce cognitive load on the end user. This is especially useful when a module has many variables and would otherwise render as an endless of form fields. Grouping has no effect on the generated output or template behavior.

So how does Runbooks know which variables to group together? The grouping strategy follows a priority order:

1. **`@runbooks:group` comments:** explicit groups defined in the `.tf` source
2. **Filename-based:** variables grouped by which `.tf` file they're defined in
3. **Prefix-based:** variables grouped by shared name prefixes (e.g., `db_*`, `vpc_*`)
4. **Required vs. Optional:** fallback grouping

### `@runbooks:group` Comments

Module authors can explicitly control grouping by adding `# @runbooks:group "Group Name"` comments directly above variable blocks in their `.tf` files:

```hcl
variable "bucket_name" {
  type        = string
  description = "Name of the S3 bucket"
}

# @runbooks:group "Lifecycle"
variable "expiration_days" {
  type        = number
  default     = 0
  description = "Days before expiration"
}

# @runbooks:group "Lifecycle"
variable "transition_to_glacier_days" {
  type        = number
  default     = 0
  description = "Days before Glacier transition"
}
```

In this example, the two lifecycle variables are grouped together under a "Lifecycle" section. The `bucket_name` variable (with no annotation) appears in an unnamed default section.

<Aside type="tip">
The `@runbooks:group` annotation is the recommended way to control variable grouping. It's explicit, portable (lives in the module source), and takes priority over all automatic grouping strategies.
</Aside>

## Template Patterns

### Terragrunt HCL (Recommended)

The most common pattern — generate a `terragrunt.hcl` file that iterates over all module variables using `_module.hcl_inputs`:

`````mdx
<TfModule id="module-vars" source="../modules/rds" />

<Template id="rds-output" path="templates/rds" inputsId="module-vars" />
`````

Inside `templates/rds/terragrunt.hcl`:

```hcl
terraform {
  source = "{{ ._module.source }}"
}

include "root" {
  path   = find_in_parent_folders("root.hcl")
  expose = true
}

inputs = {
{{- range $name, $hcl := ._module.hcl_inputs }}
  {{ $name }} = {{ $hcl }}
{{- end }}
}
```

<Aside type="note">
The `hcl_inputs` map handles type-aware formatting automatically: strings are quoted (`"value"`), booleans are raw (`true`/`false`), numbers are raw (`42`), and lists/maps are JSON-encoded.
</Aside>

### Non-Default Inputs

For idiomatic Terragrunt, you typically only declare variables that differ from their module defaults. Use `_module.hcl_inputs_non_default` to generate a minimal `inputs` block — it excludes any variable whose current value matches the declared default in the `.tf` module, while always including required variables:

`````mdx
<TfModule id="module-vars" source="../modules/rds" />

<TemplateInline inputsId="module-vars" outputPath="terragrunt.hcl" generateFile={true}>
```hcl
terraform {
  source = "{{ ._module.source }}"
}

include "root" {
  path   = find_in_parent_folders("root.hcl")
  expose = true
}

inputs = {
{{- range $name, $hcl := ._module.hcl_inputs_non_default }}
  {{ $name }} = {{ $hcl }}
{{- end }}
}
```
</TemplateInline>
`````

### Multiple Output Files

A single `<Template>` directory can produce multiple files. This is one of the main advantages over TemplateInline — you add files to the template directory without changing the runbook at all.

`````mdx
<TfModule id="module-vars" source="../modules/rds" />

<Template id="rds-scaffold" path="templates/rds-scaffold" inputsId="module-vars" />
`````

Inside `templates/rds-scaffold/terragrunt.hcl`:

```hcl
terraform {
  source = "{{ ._module.source }}"
}

inputs = {
{{- range $name, $hcl := ._module.hcl_inputs }}
  {{ $name }} = {{ $hcl }}
{{- end }}
}
```

Inside `templates/rds-scaffold/README.md`:

```markdown
# {{ ._module.readme_title }}

Source: `{{ ._module.source }}`

## Outputs

{{- range ._module.output_names }}
- `{{ . }}`
{{- end }}
```

### Extra Variables with Template

Because `<Template>` is backed by a `boilerplate.yml`, it renders **its own input form** in addition to the form that `<TfModule>` renders. Any variables defined in `boilerplate.yml` that are *not* provided by TfModule appear as extra editable fields, giving you a way to collect additional user input (e.g., environment name, team owner) that the `.tf` files know nothing about.

<Aside type="note">
Since both TfModule and Template can define variables, Runbooks merges the two sets — Template-only variables stay editable, TfModule-only variables (including `_module.*`) pass through invisibly, and overlapping variables become read-only. See [Inputs & Outputs — Variable Categories](/authoring/inputs-and-outputs/#variable-categories) for the full explanation.
</Aside>

### Using TemplateInline

For quick prototyping or simple single-file output, you can use `<TemplateInline>` to embed the template directly in the runbook. This is convenient when you want everything in one file and don't need the overhead of a template directory.

`````mdx
<TfModule id="module-vars" source="../modules/rds" />

<TemplateInline inputsId="module-vars" outputPath="terragrunt.hcl" generateFile={true}>
```hcl
terraform {
  source = "{{ ._module.source }}"
}

inputs = {
{{- range $name, $hcl := ._module.hcl_inputs }}
  {{ $name }} = {{ $hcl }}
{{- end }}
}
```
</TemplateInline>
`````

You can also reference individual variables by name:

`````mdx
<TfModule id="module-vars" source="../modules/rds" />

<TemplateInline inputsId="module-vars" outputPath="summary.txt">
```
Instance Class: {{ .instance_class }}
Engine Version: {{ .engine_version }}
Module Source: {{ ._module.source }}
```
</TemplateInline>
`````

### When to Use Template vs. TemplateInline

**`<Template>`** (recommended) points to a separate directory that contains a `boilerplate.yml` file alongside one or more template files. It renders its own input form for any extra variables defined in `boilerplate.yml`, so the user sees both the TfModule form (module variables) and the Template form (project-level variables) in the same runbook. Because it uses Boilerplate's full engine, a single block can scaffold multiple files at once. Use it for anything beyond a quick prototype — it's easy to extend without editing the runbook.

**`<TemplateInline>`** keeps the template text inline in the runbook itself. Each block produces a single file, and the only variables available are those registered by sibling components like `<TfModule>` or `<Inputs>`. Use it for quick single-file previews or when you want a self-contained runbook with no external template directory.

## Examples

### ...

Check out the [TfModule custom template feature demo](https://github.com/gruntwork-io/runbooks/tree/main/testdata/feature-demos/tf-custom-template) for a complete working example showing HCL generation, YAML output, and individual variable access from a single TfModule.

### Full example

Here's a full runbook that parses an RDS module and generates a Terragrunt configuration:

`````mdx
# Configure RDS Module

This runbook generates a `terragrunt.hcl` configuration for the RDS module.

## Configure Module Variables

<TfModule id="rds-config" source="github.com/my-org/infra-modules//modules/rds?ref=v1.0.0" />

## Preview Generated Configuration

The HCL below is dynamically generated from the module's input variables.
Change any value above and watch the preview update automatically.

<Template id="rds-output" path="templates/rds" inputsId="rds-config" />
`````
