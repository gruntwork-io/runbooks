/* eslint-disable react-refresh/only-export-components */
import { createContext, useState, useCallback, useMemo } from 'react'
import type { ReactNode } from 'react'
import type { BoilerplateConfig } from '@/types/boilerplateConfig'
import type { BoilerplateVariable } from '@/types/boilerplateVariable'

/**
 * Data stored for each registered Inputs component.
 * - We need the variable values the user entered
 * - We also need the boilerplate.yml config underlying the variables so that any consuming
 *   templates know how to render the boilerplate template!
 */
export interface InputsData {
  /** Variable values entered by the user */
  values: Record<string, unknown>
  /** Parsed boilerplate configuration (schema) */
  config: BoilerplateConfig
}

/**
 * Context interface for sharing variable values between blocks.
 * 
 * Inputs components register their values and config.
 * TemplatePreview, Command, and Check components consume merged values/configs.
 */
export interface BlockVariablesContextType {
  /** All registered inputs data, keyed by inputsId */
  inputs: Record<string, InputsData>
  
  /** Register or update an Inputs component's data */
  registerInputs: (id: string, values: Record<string, unknown>, config: BoilerplateConfig) => void
  
  /** Get merged values from one or more inputsIds (later IDs override earlier) */
  getValues: (inputsId: string | string[]) => Record<string, unknown>
  
  /** Get merged config from one or more inputsIds (later IDs override on variable name conflicts) */
  getConfig: (inputsId: string | string[]) => BoilerplateConfig
  
  /** Generate a boilerplate.yml string from merged config */
  generateYaml: (inputsId: string | string[]) => string
}

export const BlockVariablesContext = createContext<BlockVariablesContextType | undefined>(undefined)

/**
 * Provider component that enables variable sharing between Inputs and consumer components
 * (Template, TemplatePreview, Command, Check).
 * 
 * @example
 * <BlockVariablesProvider>
 *   <Inputs id="config-a">...</Inputs>
 *   <Inputs id="config-b">...</Inputs>
 *   <TemplatePreview inputsId={["config-a", "config-b"]}>...</TemplatePreview>
 *   <Command inputsId="config-a" ... />
 * </BlockVariablesProvider>
 */
export function BlockVariablesProvider({ children }: { children: ReactNode }) {
  const [inputs, setInputs] = useState<Record<string, InputsData>>({})

  const registerInputs = useCallback((id: string, values: Record<string, unknown>, config: BoilerplateConfig) => {
    setInputs(prev => {
      const existing = prev[id]
      
      // Check if values actually changed (shallow comparison of values object)
      if (existing) {
        const existingKeys = Object.keys(existing.values)
        const newKeys = Object.keys(values)
        
        // Same number of keys and all values equal
        const valuesUnchanged = existingKeys.length === newKeys.length &&
          existingKeys.every(key => existing.values[key] === values[key])
        
        if (valuesUnchanged) {
          // No change, return previous state to avoid re-render
          return prev
        }
      }
      
      console.log(`[BlockVariablesContext] registerInputs updating [${id}]:`, { values, config })
      return {
        ...prev,
        [id]: { values, config }
      }
    })
  }, [])

  const getValues = useCallback((inputsId: string | string[]): Record<string, unknown> => {
    const ids = Array.isArray(inputsId) ? inputsId : [inputsId]
    // Merge values from all inputsIds, later IDs override earlier ones
    return ids.reduce((acc, id) => {
      const data = inputs[id]
      return data ? { ...acc, ...data.values } : acc
    }, {} as Record<string, unknown>)
  }, [inputs])

  const getConfig = useCallback((inputsId: string | string[]): BoilerplateConfig => {
    const ids = Array.isArray(inputsId) ? inputsId : [inputsId]
    
    // Collect all variables from all configs
    const allVariables: BoilerplateVariable[] = []
    for (const id of ids) {
      const data = inputs[id]
      if (data?.config?.variables) {
        allVariables.push(...data.config.variables)
      }
    }
    
    // Dedupe by variable name, keeping the last occurrence (later IDs win)
    const variableMap = new Map<string, BoilerplateVariable>()
    for (const variable of allVariables) {
      variableMap.set(variable.name, variable)
    }
    
    return {
      variables: Array.from(variableMap.values()),
      rawYaml: '' // Will be regenerated by generateYaml
    }
  }, [inputs])

  const generateYaml = useCallback((inputsId: string | string[]): string => {
    const config = getConfig(inputsId)
    
    if (!config.variables || config.variables.length === 0) {
      return 'variables: []'
    }
    
    // Generate minimal YAML for boilerplate
    const lines = ['variables:']
    for (const variable of config.variables) {
      lines.push(`  - name: ${variable.name}`)
      lines.push(`    type: ${variable.type || 'string'}`)
      if (variable.description) {
        lines.push(`    description: "${variable.description.replace(/"/g, '\\"')}"`)
      }
      if (variable.default !== undefined) {
        if (typeof variable.default === 'string') {
          lines.push(`    default: "${variable.default.replace(/"/g, '\\"')}"`)
        } else {
          lines.push(`    default: ${JSON.stringify(variable.default)}`)
        }
      }
      if (variable.options && variable.options.length > 0) {
        lines.push(`    options:`)
        for (const option of variable.options) {
          lines.push(`      - ${option}`)
        }
      }
    }
    
    return lines.join('\n')
  }, [getConfig])

  const contextValue = useMemo(() => ({
    inputs,
    registerInputs,
    getValues,
    getConfig,
    generateYaml
  }), [inputs, registerInputs, getValues, getConfig, generateYaml])

  return (
    <BlockVariablesContext.Provider value={contextValue}>
      {children}
    </BlockVariablesContext.Provider>
  )
}

// Hooks are in a separate file to satisfy react-refresh requirements
// See: useBlockVariables.ts

