import { useApi } from './useApi';
import type { UseApiReturn } from './useApi';
import { useMemo, useCallback, useEffect } from 'react';
import { useFileTree } from './useFileTree';
import type { FileTreeNode } from '@/components/artifacts/code/FileTree';

interface BoilerplateRenderResult {
  message:      string,
  outputDir:    string,
  templatePath: string,
  fileTree:     FileTree,
  // Cleanup information from manifest-based rendering
  deletedFiles?:  string[], // Files deleted due to orphaning
  createdFiles?:  string[], // Newly created files
  modifiedFiles?: string[], // Files with changed content
  skippedFiles?:  string[], // Files unchanged (no write needed)
}

type FileTree = FileTreeNode[]

// Enhanced return type that includes auto-rendering functionality
interface UseApiBoilerplateRenderResult extends UseApiReturn<BoilerplateRenderResult> {
  isAutoRendering: boolean;
  autoRender: (templatePath: string, variables: Record<string, unknown>) => void;
}

/**
 * Hook for rendering boilerplate templates via the API.
 * 
 * @param templatePath - Path to the boilerplate template directory (required)
 * @param templateId - Unique ID of the Template component (required)
 * @param variables - Variables to pass to the template
 * @param shouldFetch - Whether to fetch immediately (default: true)
 * @param target - Where template output is written: "generated" (default) or "worktree"
 * 
 * The backend uses templateId to track which files were generated by this template.
 * On re-render, it automatically cleans up orphaned files (e.g., when switching
 * from Python to Node.js runtime) and only writes files that have changed.
 */
export function useApiBoilerplateRender(
  templatePath: string,
  templateId: string,
  variables?: Record<string, unknown>,
  shouldFetch: boolean = true,
  target?: 'generated' | 'worktree'
): UseApiBoilerplateRenderResult {
  const { setFileTree } = useFileTree();  // The FileTree is where we render the list of generated files

  // Build the request body - both templatePath and templateId are required
  const requestBody = useMemo(() => {
    if (!shouldFetch) return null;
    if (templatePath && templateId) {
      return { templatePath, templateId, variables, ...(target ? { target } : {}) };
    }
    return null;
  }, [templatePath, templateId, variables, shouldFetch, target]);

  const apiResult = useApi<BoilerplateRenderResult>(
    shouldFetch ? '/api/boilerplate/render' : '', // Empty endpoint when shouldFetch is false
    'POST', 
    requestBody || undefined,
    200 // 200ms debounce timeout
  );

  // Auto-render function using the debounced request
  const { debouncedRequest } = apiResult;
  const autoRender = useCallback((templatePath: string, variables: Record<string, unknown>) => {
    if (debouncedRequest && templatePath && templateId) {
      debouncedRequest({ templatePath, templateId, variables, ...(target ? { target } : {}) });
    }
  }, [debouncedRequest, templateId, target]);

  // Handle file tree updates when data changes (Generated tab only)
  // When target is worktree, output went to the git repo â€” do not overwrite Generated with worktree tree
  useEffect(() => {
    if (target === 'worktree') return;
    const fileTreeData = apiResult.data?.fileTree;
    if (fileTreeData && Array.isArray(fileTreeData)) {
      setFileTree(fileTreeData);
    }
  }, [apiResult.data?.fileTree, setFileTree, target]);

  return {
    ...apiResult,
    isAutoRendering: apiResult.isLoading,
    autoRender
  };
}